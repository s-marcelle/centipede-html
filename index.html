<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Centipede Clone</title>
    <style>
        body { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; background-color: #111; font-family: 'Courier New', Courier, monospace; color: #fff; overflow: hidden; touch-action: none; }
        canvas { border: 2px solid #fff; background-color: #000; cursor: none; touch-action: none; }
        #gameInfo { margin-top: 10px; font-size: 1.2em; width: 95%; max-width: 600px; display: flex; justify-content: space-between; }
    </style>
</head>
<body>
    <div id="gameInfo">
        <span id="score">Score: 0</span>
        <span id="lives">Lives: 3</span>
        <span id="level">Level: 1</span>
    </div>
    <canvas id="gameCanvas" width="600" height="640"></canvas>

    <script>
    // --- Game Code Wrapped in IIFE to create a scope ---
    (function() {

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const levelEl = document.getElementById('level');

        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        console.log("Is Touch Device:", isTouchDevice);

        // --- Game Constants (Same as before) ---
        const GRID_SIZE = 20; const WIDTH = canvas.width; const HEIGHT = canvas.height;
        const ROWS = HEIGHT / GRID_SIZE; const COLS = WIDTH / GRID_SIZE;
        const PLAYER_AREA_ROWS = 6; const PLAYER_START_ROW = ROWS - PLAYER_AREA_ROWS;
        const PLAYER_START_Y = PLAYER_START_ROW * GRID_SIZE + GRID_SIZE / 2;
        const PLAYER_SPEED = 5; const BULLET_SPEED = 8;
        const PLAYER_SHOOT_COOLDOWN_NORMAL = 150; const PLAYER_SHOOT_COOLDOWN_RAPID = 75;
        const INVINCIBILITY_DURATION = 2000; const POWERUP_DROP_CHANCE = 0.12;
        const BASE_POWERUP_DURATION = 10000; const RAPID_FIRE_DURATION = 15000; const SHIELD_DURATION = 20000;
        const CENTIPEDE_START_LENGTH = 60; const CENTIPEDE_SPEED_BASE = 1;
        const MAX_CENTIPEDE_SPEED_MULTIPLIER = 3.5; const CENTIPEDE_LEVEL_SPEED_INCREASE = 0.07;
        const CENTIPEDE_ASCEND_SPEED_BOOST = 1.5; const MUSHROOM_HEALTH = 4;
        const POISON_EXPLOSION_RADIUS = GRID_SIZE * 2.5; const FLEA_SPAWN_THRESHOLD = 5;
        const FLEA_HEALTH = 2; const FLEA_SPEED_BASE = CENTIPEDE_SPEED_BASE * 2.5;
        const MAX_FLEA_SPEED_MULTIPLIER = 2.5; const FLEA_LEVEL_SPEED_INCREASE = 0.05;
        const SPIDER_SPEED_BASE = 3; const MAX_SPIDER_SPEED_MULTIPLIER = 3.0; const SPIDER_LEVEL_SPEED_INCREASE = 0.05;
        const SCORPION_SPEED_BASE = 2; const MAX_SCORPION_SPEED_MULTIPLIER = 3.0; const SCORPION_LEVEL_SPEED_INCREASE = 0.05;
        const BOMBER_SPEED_BASE = 1.5; const BOMBER_LEVEL_SPEED_INCREASE = 0.05; const MAX_BOMBER_SPEED_MULTIPLIER = 2.5;
        const BOMB_SPEED = 3; const BOMB_DROP_INTERVAL_BASE = 3000; const BOMB_DROP_INTERVAL_RANDOM = 2000;
        const MIN_SPIDER_SPAWN_TIME = 1500; const MIN_FLEA_SPAWN_TIME = 2500; const MIN_SCORPION_SPAWN_TIME = 4000; const MIN_BOMBER_SPAWN_TIME = 6000;
        const SCORE_CENTIPEDE_HEAD = 100; const SCORE_CENTIPEDE_BODY = 10; const SCORE_SPIDER = 600; const SCORE_FLEA = 200; const SCORE_SCORPION = 1000; const SCORE_BOMBER = 800;
        const SCORE_MUSHROOM_DESTROY = 1; const SCORE_MUSHROOM_REPAIR = 1; const EXTRA_LIFE_SCORE = 10000;

        // --- Game State (Same as before) ---
        let score = 0; let lives = 3; let level = 1; let isGameOver = false; let gamePaused = false;
        let lastTime = 0; let pausedTime = 0; let keys = {}; let mouseX = WIDTH / 2; let mouseY = PLAYER_START_Y;
        let nextLifeScore = EXTRA_LIFE_SCORE; let isCentipedeAscending = false;
        let player; let canShoot = true; let shootCooldownTimer = 0; let invincibilityTimer = 0;
        let isShielded = false; let shieldTimer = 0; let activePowerUp = null; let powerUpTimer = 0;
        let bullets = []; let mushrooms = []; let centipedeSegments = []; let spiders = []; let fleas = [];
        let scorpions = []; let bombers = []; let bombs = []; let powerUps = []; let particles = [];
        const MAX_BULLETS = 50; const bulletPool = []; const MAX_PARTICLES = 150; const particlePool = [];
        const MAX_BOMBS = 20; const bombPool = [];

        // --- Classes (GameObject, Player, Bullet, Mushroom, CentipedeSegment, Spider, Flea, Scorpion, Bomber, Bomb, PowerUp, Particle) ---
        // ... (All class definitions are exactly the same as the previous version - include them here) ...
        // Example (replace with full class definitions):
        class GameObject { constructor(x, y, width, height, color) { this.x = x; this.y = y; this.width = width; this.height = height; this.color = color; this.active = true; } draw(ctx) { if (!this.active) return; ctx.fillStyle = this.color; ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height); } collidesWith(other) { if (!this.active || !other.active) return false; return (this.x - this.width / 2 < other.x + other.width / 2 && this.x + this.width / 2 > other.x - other.width / 2 && this.y - this.height / 2 < other.y + other.height / 2 && this.y + this.height / 2 > other.y - other.height / 2); } getGridPos() { return { col: Math.floor(this.x / GRID_SIZE), row: Math.floor(this.y / GRID_SIZE) }; } getCenterGridPos() { return { col: Math.floor(this.x / GRID_SIZE), row: Math.floor(this.y / GRID_SIZE) }; } }
        class Player extends GameObject { constructor(x, y) { super(x, y, GRID_SIZE * 0.8, GRID_SIZE * 0.8, 'lime'); this.shootCooldown = PLAYER_SHOOT_COOLDOWN_NORMAL; this.isShielded = false; this.shieldTimer = 0; } update(deltaTime) { if (this.shieldTimer > 0) { this.shieldTimer -= deltaTime; if (this.shieldTimer <= 0) this.isShielded = false; } if (invincibilityTimer > 0) invincibilityTimer -= deltaTime; let moveX = 0, moveY = 0; if (keys['ArrowLeft'] || keys['a']) moveX -= PLAYER_SPEED; if (keys['ArrowRight'] || keys['d']) moveX += PLAYER_SPEED; if (keys['ArrowUp'] || keys['w']) moveY -= PLAYER_SPEED; if (keys['ArrowDown'] || keys['s']) moveY += PLAYER_SPEED; let targetX = this.x, targetY = this.y; let isKeyboardMoving = (moveX !== 0 || moveY !== 0); if (isKeyboardMoving) { targetX += moveX; targetY += moveY; } else { targetX = mouseX; targetY = mouseY; } targetX = Math.max(this.width / 2, Math.min(WIDTH - this.width / 2, targetX)); targetY = Math.max(PLAYER_START_Y - GRID_SIZE / 2, Math.min(HEIGHT - this.height / 2, targetY)); if (isKeyboardMoving) { let blockedH = false, blockedV = false; mushrooms.forEach(m => { if (m.active) { const overlap = (Math.abs(targetX - m.x) < (this.width + m.width) / 2 && Math.abs(targetY - m.y) < (this.height + m.height) / 2); if (overlap) { if (moveX !== 0 && Math.abs(this.x + moveX - m.x) < (this.width + m.width) / 2 && Math.abs(this.y - m.y) < (this.height + m.height) / 2) blockedH = true; if (moveY !== 0 && Math.abs(this.x - m.x) < (this.width + m.width) / 2 && Math.abs(this.y + moveY - m.y) < (this.height + m.height) / 2) blockedV = true; } } }); if (blockedH) targetX = this.x; if (blockedV) targetY = this.y; targetX = Math.max(this.width / 2, Math.min(WIDTH - this.width / 2, targetX)); targetY = Math.max(PLAYER_START_Y - GRID_SIZE / 2, Math.min(HEIGHT - this.height / 2, targetY)); } this.x = targetX; this.y = targetY; if (!canShoot) { shootCooldownTimer -= deltaTime; if (shootCooldownTimer <= 0) canShoot = true; } if (isTouchDevice) { this.triggerShoot(); } else if ((keys[' '] || keys['Control']) && canShoot) { this.triggerShoot(); } if (activePowerUp === 'rapid') { powerUpTimer -= deltaTime; if (powerUpTimer <= 0) { activePowerUp = null; powerUpTimer = 0; } } } triggerShoot() { if (!canShoot || !this.active) return; if (activePowerUp === 'rapid') { this.shootCooldown = PLAYER_SHOOT_COOLDOWN_RAPID; } else { this.shootCooldown = PLAYER_SHOOT_COOLDOWN_NORMAL; } if (activePowerUp === 'spread') { spawnBullet(this.x, this.y, -0.2); spawnBullet(this.x, this.y, 0); spawnBullet(this.x, this.y, 0.2); } else { spawnBullet(this.x, this.y); } canShoot = false; shootCooldownTimer = this.shootCooldown; } draw(ctx) { if (!this.active) return; const w = this.width, h = this.height, x = this.x, y = this.y; if (this.isShielded) { ctx.strokeStyle = 'cyan'; ctx.lineWidth = 2; ctx.beginPath(); const shieldRadius = w * 0.7 + Math.sin(Date.now() / 150) * 2; ctx.arc(x, y, shieldRadius, 0, Math.PI * 2); ctx.stroke(); ctx.lineWidth = 1; } else if (invincibilityTimer > 0) { const alpha = 0.5 + Math.abs(Math.sin(invincibilityTimer / 100)) * 0.5; ctx.globalAlpha = alpha; } ctx.fillStyle = this.color; ctx.beginPath(); ctx.moveTo(x, y - h / 2); ctx.lineTo(x - w / 2, y + h / 2); ctx.lineTo(x + w / 2, y + h / 2); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#008000'; ctx.beginPath(); ctx.moveTo(x, y - h / 4); ctx.lineTo(x - w / 4, y + h / 4); ctx.lineTo(x + w / 4, y + h / 4); ctx.closePath(); ctx.fill(); ctx.fillStyle = 'grey'; ctx.fillRect(x - 2, y - h * 0.8, 4, h * 0.4); ctx.fillStyle = 'orange'; ctx.beginPath(); ctx.ellipse(x, y + h * 0.6, w * 0.2, h * 0.15, 0, 0, Math.PI * 2); ctx.fill(); const currentActivePower = this.isShielded ? 'shield' : activePowerUp; if (currentActivePower === 'spread') { ctx.fillStyle = 'cyan'; ctx.fillRect(x-2, y-h/2-6, 4, 4); ctx.fillRect(x-7, y-h/2-6, 4, 4); ctx.fillRect(x+3, y-h/2-6, 4, 4); } else if (currentActivePower === 'rapid') { ctx.fillStyle = 'yellow'; ctx.fillRect(x-2, y-h/2-6, 4, 4); } else if (currentActivePower === 'shield') { ctx.fillStyle = 'cyan'; ctx.font = "bold 10px Courier New"; ctx.textAlign="center"; ctx.fillText("H", x, y - h/2 - 6);} ctx.globalAlpha = 1.0; } hit() { if (this.isShielded) { spawnParticles(this.x, this.y, 5, 'cyan'); return; } if (invincibilityTimer > 0) return; lives--; updateUI(); spawnParticles(this.x, this.y, 20, 'lime'); if (lives <= 0) { isGameOver = true; } else { invincibilityTimer = INVINCIBILITY_DURATION; this.x = WIDTH / 2; this.y = PLAYER_START_Y + GRID_SIZE; mouseX = this.x; mouseY = this.y; activePowerUp = null; powerUpTimer = 0; this.isShielded = false; this.shieldTimer = 0; } } }
        class Bullet extends GameObject { constructor(x, y, angle = 0) { super(x, y - GRID_SIZE / 2, 4, 10, 'yellow'); this.speed = BULLET_SPEED; this.vx = Math.sin(angle) * this.speed; this.vy = -Math.cos(angle) * this.speed; } update(deltaTime) { if (!this.active) return; this.y += this.vy; this.x += this.vx; if (this.y < 0) this.active = false; } reset(x, y, angle = 0) { this.x = x; this.y = y - GRID_SIZE / 2; this.vx = Math.sin(angle) * this.speed; this.vy = -Math.cos(angle) * this.speed; this.active = true; } }
        class Mushroom extends GameObject { constructor(x, y) { const gX=Math.floor(x/GRID_SIZE), gY=Math.floor(y/GRID_SIZE); super(gX*GRID_SIZE+GRID_SIZE/2, gY*GRID_SIZE+GRID_SIZE/2, GRID_SIZE*0.9, GRID_SIZE*0.9, 'red'); this.health = MUSHROOM_HEALTH; this.isPoisoned = false; this.maxHealth = MUSHROOM_HEALTH; this.healthColors = ['#A00000', '#D00000', '#F04040', 'red']; this.poisonColors = ['#006400', '#008000', '#32CD32', 'lime']; this.spotColor = 'white'; this.stemColor = '#FFDAB9'; this.poisonStemColor = '#90EE90'; this.updateVisuals(); } hit() { if (!this.active) return false; this.health--; spawnParticles(this.x, this.y, 3, this.currentCapColor); if (this.health <= 0) { this.active = false; addScore(SCORE_MUSHROOM_DESTROY); if (this.isPoisoned) { triggerPoisonExplosion(this.x, this.y); } else { spawnParticles(this.x, this.y, 10, this.currentCapColor); } return true; } this.updateVisuals(); return false; } poison() { if (!this.isPoisoned) { this.isPoisoned = true; this.updateVisuals(); } } updateVisuals() { const c = this.isPoisoned ? this.poisonColors : this.healthColors; this.currentCapColor = c[Math.max(0, this.health - 1)]; this.currentStemColor = this.isPoisoned ? this.poisonStemColor : this.stemColor; } draw(ctx) { if (!this.active) return; const r=this.width/2, sw=this.width/3, sh=this.height/2, cY=this.y-sh/4, sY=this.y+sh/4; ctx.fillStyle=this.currentStemColor; ctx.fillRect(this.x-sw/2, sY-sh/2, sw, sh); ctx.fillStyle=this.currentCapColor; ctx.beginPath(); ctx.arc(this.x, cY, r, Math.PI, 0); ctx.fill(); ctx.fillStyle=this.spotColor; const ss=Math.max(1, this.width*0.08); if (this.health>=3){ctx.beginPath();ctx.arc(this.x-r*0.5, cY-r*0.2, ss, 0, Math.PI*2);ctx.fill();} if(this.health>=1){ctx.beginPath();ctx.arc(this.x+r*0.4, cY-r*0.4, ss, 0, Math.PI*2);ctx.fill();} if(this.health>=2){ctx.beginPath();ctx.arc(this.x, cY+r*0.3, ss*1.2, 0, Math.PI*2);ctx.fill();} } }
        class CentipedeSegment extends GameObject { constructor(x, y, isHead = false, nextSegment = null) { const gX=Math.floor(x/GRID_SIZE), gY=Math.floor(y/GRID_SIZE); super(gX*GRID_SIZE+GRID_SIZE/2, gY*GRID_SIZE+GRID_SIZE/2, GRID_SIZE*0.9, GRID_SIZE*0.9, isHead?'pink':'purple'); this.isHead = isHead; this.nextSegment = nextSegment; this.dx = CENTIPEDE_SPEED_BASE; this.dy = 0; this.moveCounter = 0; this.targetY = -1; this.updateSpeedForLevel(); this.bodyColor='#FF00FF'; this.headColor='#FF69B4'; this.eyeColor='black'; this.legColor='#FFA500'; this.isAscendingBoosted = false; } updateSpeedForLevel(boost = false) { let levelMultiplier = Math.min(MAX_CENTIPEDE_SPEED_MULTIPLIER, 1 + (level - 1) * CENTIPEDE_LEVEL_SPEED_INCREASE); if (this.isAscendingBoosted || boost) { levelMultiplier *= CENTIPEDE_ASCEND_SPEED_BOOST; this.isAscendingBoosted = true; } this.speedMultiplier = levelMultiplier; this.moveThreshold = Math.max(1, Math.floor(GRID_SIZE / (CENTIPEDE_SPEED_BASE * this.speedMultiplier))); } update(deltaTime) { this.updateSpeedForLevel(); if (!this.active) return; this.moveCounter++; if (this.moveCounter < this.moveThreshold) return; this.moveCounter = 0; let currentGridPos = this.getCenterGridPos(); let nextGridCol = currentGridPos.col + this.dx; let nextGridRow = currentGridPos.row + this.dy; if (this.dy !== 0) { if (currentGridPos.row === this.targetY) { this.dy = 0; this.targetY = -1; if (isCentipedeAscending && currentGridPos.row === 0) { this.dx *= -1; } else if (!isCentipedeAscending) { this.dx *= -1; } else if (isCentipedeAscending) { this.dx *= -1; } nextGridCol = currentGridPos.col + this.dx; nextGridRow = currentGridPos.row; } else { nextGridCol = currentGridPos.col; nextGridRow = currentGridPos.row + this.dy; if (this.dy > 0 && nextGridRow >= ROWS) { nextGridRow = ROWS - 1; this.dy = 0; this.dx *= -1; this.targetY = -1; } else if (this.dy < 0 && nextGridRow < 0) { nextGridRow = 0; this.dy = 0; this.dx *= -1; this.targetY = -1; } this.x = nextGridCol * GRID_SIZE + GRID_SIZE / 2; this.y = nextGridRow * GRID_SIZE + GRID_SIZE / 2; return; } } let collision = false; if (nextGridCol < 0 || nextGridCol >= COLS) { collision = true; } else if (!isCentipedeAscending) { mushrooms.forEach(mushroom => { if (mushroom.active) { const mushPos = mushroom.getGridPos(); if (mushPos.col === nextGridCol && mushPos.row === nextGridRow) { collision = true; } else if (mushroom.isPoisoned && mushPos.col === nextGridCol && mushPos.row === nextGridRow + 1) { collision = true; } } }); } if (collision) { const turnDirection = isCentipedeAscending ? -1 : 1; if (turnDirection > 0 && currentGridPos.row >= ROWS - 1) { this.dy = 0; this.dx *= -1; this.targetY = -1; } else if (turnDirection < 0 && currentGridPos.row <= 0) { this.dy = 0; this.dx *= -1; this.targetY = -1; } else { this.dy = turnDirection; this.targetY = currentGridPos.row + this.dy; nextGridCol = currentGridPos.col; nextGridRow = currentGridPos.row + this.dy; } } else { nextGridRow = currentGridPos.row; } if (nextGridRow>=ROWS) nextGridRow=ROWS-1; if (nextGridRow<0) nextGridRow=0; if (nextGridCol<0) nextGridCol=0; if (nextGridCol>=COLS) nextGridCol=COLS-1; this.x=nextGridCol*GRID_SIZE+GRID_SIZE/2; this.y=nextGridRow*GRID_SIZE+GRID_SIZE/2; } draw(ctx) { if (!this.active) return; const r=this.width/2, lL=r*0.6, lO=r*0.8; ctx.strokeStyle=this.legColor; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(this.x-lO,this.y); ctx.lineTo(this.x-lO-lL, this.y+lL*(this.dy!==0?-0.5:1)); ctx.moveTo(this.x+lO,this.y); ctx.lineTo(this.x+lO+lL, this.y+lL*(this.dy!==0?-0.5:1)); ctx.stroke(); ctx.lineWidth=1; ctx.fillStyle=this.isHead?this.headColor:this.bodyColor; ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI*2); ctx.fill(); if (this.isHead) { ctx.fillStyle=this.eyeColor; const es=r*0.2, exo=r*0.3*(this.dx>0?1:-1), eyo=-r*0.2; ctx.beginPath(); ctx.arc(this.x+exo, this.y+eyo, es, 0, Math.PI*2); ctx.arc(this.x-exo, this.y+eyo, es, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle=this.headColor; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(this.x+exo, this.y+eyo); ctx.lineTo(this.x+exo*2, this.y+eyo-r); ctx.moveTo(this.x-exo, this.y+eyo); ctx.lineTo(this.x-exo*2, this.y+eyo-r); ctx.stroke(); } } hit() { this.active = false; addScore(this.isHead ? SCORE_CENTIPEDE_HEAD : SCORE_CENTIPEDE_BODY); spawnParticles(this.x, this.y, 5, this.isHead?this.headColor:this.bodyColor); spawnMushroomAt(this.x, this.y); if (this.nextSegment && this.nextSegment.active) { this.nextSegment.isHead = true; this.nextSegment.updateSpeedForLevel(); } maybeSpawnPowerUp(this.x, this.y); } }
        class Spider extends GameObject { constructor(x, y) { super(x, y, GRID_SIZE*1.2, GRID_SIZE*1.2, '#FFA500'); this.dx=0; this.dy=0; this.updateSpeedForLevel(); this.changeDirectionTimer=0; this.changeDirectionInterval=500+Math.random()*500; this.minY=PLAYER_START_ROW*GRID_SIZE-GRID_SIZE; this.maxY=HEIGHT-this.height/2; this.legColor='#8B4513'; } updateSpeedForLevel() { const sm=Math.min(MAX_SPIDER_SPEED_MULTIPLIER, 1+(level-1)*SPIDER_LEVEL_SPEED_INCREASE); this.speed=SPIDER_SPEED_BASE*sm*(0.8+Math.random()*0.4); const csX=Math.sign(this.dx)||(Math.random()<0.5?1:-1), csY=Math.sign(this.dy)||(Math.random()<0.5?1:-1); this.dx=csX*this.speed*(Math.random()*0.5+0.5); this.dy=csY*this.speed*(Math.random()*0.5+0.5); } update(deltaTime) { if (!this.active) return; this.updateSpeedForLevel(); this.changeDirectionTimer-=deltaTime; if (this.changeDirectionTimer<=0) { this.dx=(Math.random()<0.5?1:-1)*this.speed*(Math.random()*0.5+0.5); if (Math.random()<0.3) this.dy*=-1; else this.dy=(Math.sign(this.dy)||(Math.random()<0.5?1:-1))*this.speed*(Math.random()*0.5+0.5); this.changeDirectionTimer=this.changeDirectionInterval; } let nxtX=this.x+this.dx, nxtY=this.y+this.dy; if (nxtX<this.width/2||nxtX>WIDTH-this.width/2){this.dx*=-1; nxtX=this.x+this.dx;} if (nxtY<this.minY||nxtY>this.maxY){this.dy*=-1; nxtY=this.y+this.dy; nxtY=Math.max(this.minY, Math.min(this.maxY, nxtY));} this.x=nxtX; this.y=nxtY; mushrooms.forEach(m=>{if(m.active&&this.collidesWith(m)){if(Math.random()<0.05){m.hit();}}}); } draw(ctx) { if (!this.active) return; const br=this.width*0.3, hr=br*0.7, ll=this.width*0.6, lt=2; ctx.strokeStyle=this.legColor; ctx.lineWidth=lt; ctx.beginPath(); ctx.moveTo(this.x-br*0.5,this.y-br*0.5); ctx.lineTo(this.x-br*0.8-ll*0.6,this.y-br-ll*0.8); ctx.moveTo(this.x+br*0.5,this.y-br*0.5); ctx.lineTo(this.x+br*0.8+ll*0.6,this.y-br-ll*0.8); ctx.moveTo(this.x-br,this.y); ctx.lineTo(this.x-br-ll,this.y-ll*0.3); ctx.moveTo(this.x+br,this.y); ctx.lineTo(this.x+br+ll,this.y-ll*0.3); ctx.moveTo(this.x-br,this.y); ctx.lineTo(this.x-br-ll*0.9,this.y+ll*0.5); ctx.moveTo(this.x+br,this.y); ctx.lineTo(this.x+br+ll*0.9,this.y+ll*0.5); ctx.moveTo(this.x-br*0.5,this.y+br*0.5); ctx.lineTo(this.x-br*0.8-ll*0.5,this.y+br+ll*0.7); ctx.moveTo(this.x+br*0.5,this.y+br*0.5); ctx.lineTo(this.x+br*0.8+ll*0.5,this.y+br+ll*0.7); ctx.stroke(); ctx.fillStyle=this.color; ctx.beginPath(); ctx.ellipse(this.x,this.y,br,br*1.2,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#D2691E'; ctx.beginPath(); ctx.arc(this.x,this.y-br*0.8,hr,0,Math.PI*2); ctx.fill(); ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(this.x-hr*0.3,this.y-br*0.9,2,0,Math.PI*2); ctx.arc(this.x+hr*0.3,this.y-br*0.9,2,0,Math.PI*2); ctx.fill(); ctx.lineWidth=1; } hit() { this.active=false; addScore(SCORE_SPIDER); spawnParticles(this.x, this.y, 15, this.color); maybeSpawnPowerUp(this.x, this.y); }}
        class Flea extends GameObject { constructor() { const sC=Math.floor(Math.random()*COLS); super(sC*GRID_SIZE+GRID_SIZE/2,-GRID_SIZE/2,GRID_SIZE*0.7,GRID_SIZE*1.2,'#A0522D'); this.health=FLEA_HEALTH; this.dropChance=0.2+level*0.02; this.lastDropRow=-1; this.updateSpeedForLevel(); this.color1='#A0522D'; this.color2='#D2691E'; } updateSpeedForLevel() { const sm=Math.min(MAX_FLEA_SPEED_MULTIPLIER, 1+(level-1)*FLEA_LEVEL_SPEED_INCREASE); this.speed=FLEA_SPEED_BASE*sm; } update(deltaTime) { if (!this.active) return; this.updateSpeedForLevel(); this.y+=this.speed; const cGP=this.getGridPos(); if (cGP.row>this.lastDropRow && cGP.row<PLAYER_START_ROW) { this.lastDropRow=cGP.row; if (Math.random()<this.dropChance) { const ex=mushrooms.some(m=>m.active && m.getGridPos().col===cGP.col && m.getGridPos().row===cGP.row); if (!ex) mushrooms.push(new Mushroom(this.x, this.y)); } } if (this.y > HEIGHT+this.height) this.active=false; } draw(ctx) { if (!this.active) return; const w=this.width, h=this.height; ctx.fillStyle=this.health===2?this.color1:this.color2; ctx.beginPath(); ctx.ellipse(this.x, this.y, w/2, h/2, 0, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle='black'; ctx.lineWidth=0.5; ctx.beginPath(); ctx.moveTo(this.x-w/2, this.y-h*0.2); ctx.lineTo(this.x+w/2, this.y-h*0.2); ctx.moveTo(this.x-w/2, this.y+h*0.2); ctx.lineTo(this.x+w/2, this.y+h*0.2); ctx.stroke(); ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(this.x-w*0.2, this.y-h*0.3, 1.5, 0, Math.PI*2); ctx.arc(this.x+w*0.2, this.y-h*0.3, 1.5, 0, Math.PI*2); ctx.fill(); ctx.lineWidth=1; } hit() { this.health--; spawnParticles(this.x, this.y, 4, this.health===1?this.color2:this.color1); if (this.health<=0) { this.active=false; addScore(SCORE_FLEA); spawnParticles(this.x, this.y, 10, this.color2); maybeSpawnPowerUp(this.x, this.y); } }}
        class Scorpion extends GameObject { constructor() { const sY=Math.floor(Math.random()*(PLAYER_START_ROW-5))*GRID_SIZE+GRID_SIZE/2, sX=Math.random()<0.5?-GRID_SIZE/2:WIDTH+GRID_SIZE/2; super(sX,sY,GRID_SIZE*1.8,GRID_SIZE*0.9,'#8B0000'); this.speed=0; this.dx=sX<0?1:-1; this.updateSpeedForLevel(); this.segmentColor='#DC143C'; this.stingerColor='yellow'; } updateSpeedForLevel() { const sm=Math.min(MAX_SCORPION_SPEED_MULTIPLIER, 1+(level-1)*SCORPION_LEVEL_SPEED_INCREASE); this.speed=SCORPION_SPEED_BASE*sm; const dirSign=Math.sign(this.dx)||(this.x<WIDTH/2?1:-1); this.dx=dirSign*this.speed; } update(deltaTime) { if (!this.active) return; this.updateSpeedForLevel(); this.x+=this.dx; const gp=this.getCenterGridPos(); mushrooms.forEach(m=>{if(m.active&&!m.isPoisoned){const mp=m.getGridPos(); if(mp.col===gp.col && mp.row===gp.row){m.poison(); spawnParticles(m.x,m.y,5,'green');}}}); if ((this.dx>0&&this.x>WIDTH+this.width)||(this.dx<0&&this.x<-this.width))this.active=false; } draw(ctx) { if (!this.active) return; const w=this.width, h=this.height, bw=w*0.7, tbx=this.x+(this.dx>0?-bw/2:bw/2), tex=this.x+(this.dx>0?-w*0.8:w*0.8); ctx.fillStyle=this.segmentColor; ctx.fillRect(this.x-bw/2, this.y-h/2, bw*0.6, h); ctx.fillStyle=this.color; ctx.fillRect(this.x-bw/2+bw*0.4, this.y-h/2, bw*0.6, h); const pbx=this.x+(this.dx>0?bw/2:-bw/2), ptx=pbx+(this.dx>0?w*0.3:-w*0.3), pyo=h*0.4; ctx.beginPath(); ctx.moveTo(pbx, this.y-pyo); ctx.lineTo(ptx, this.y-pyo*1.5); ctx.lineTo(ptx*0.9+pbx*0.1, this.y); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(pbx, this.y+pyo); ctx.lineTo(ptx, this.y+pyo*1.5); ctx.lineTo(ptx*0.9+pbx*0.1, this.y); ctx.closePath(); ctx.fill(); ctx.strokeStyle=this.segmentColor; ctx.lineWidth=h*0.4; ctx.beginPath(); ctx.moveTo(tbx, this.y); ctx.quadraticCurveTo((tbx+tex)/2, this.y-h*1.8, tex, this.y-h*0.5); ctx.stroke(); ctx.fillStyle=this.stingerColor; ctx.beginPath(); ctx.moveTo(tex, this.y-h*0.5); ctx.lineTo(tex+(this.dx>0?-5:5), this.y-h*0.5-5); ctx.lineTo(tex+(this.dx>0?-2:2), this.y-h*0.5); ctx.fill(); ctx.lineWidth=1; } hit() { this.active=false; addScore(SCORE_SCORPION); spawnParticles(this.x, this.y, 15, this.color); maybeSpawnPowerUp(this.x, this.y); }}
        class Bomber extends GameObject { constructor() { const startX = Math.random() < 0.5 ? -GRID_SIZE / 2 : WIDTH + GRID_SIZE / 2; const startY = GRID_SIZE * 1.5; super(startX, startY, GRID_SIZE * 1.6, GRID_SIZE * 0.8, '#4682B4'); this.speed = 0; this.dx = startX < 0 ? 1 : -1; this.updateSpeedForLevel(); this.bombDropTimer = BOMB_DROP_INTERVAL_BASE / 2 + Math.random() * BOMB_DROP_INTERVAL_RANDOM; this.wingColor = '#B0C4DE'; } updateSpeedForLevel() { const speedMultiplier = Math.min(MAX_BOMBER_SPEED_MULTIPLIER, 1 + (level - 1) * BOMBER_LEVEL_SPEED_INCREASE); this.speed = BOMBER_SPEED_BASE * speedMultiplier; const directionSign = Math.sign(this.dx) || (this.x < WIDTH / 2 ? 1 : -1); this.dx = directionSign * this.speed; } update(deltaTime) { if (!this.active) return; this.updateSpeedForLevel(); this.x += this.dx; if ((this.dx > 0 && this.x > WIDTH - this.width / 2) || (this.dx < 0 && this.x < this.width / 2)) { this.dx *= -1; this.x += this.dx; } this.bombDropTimer -= deltaTime; if (this.bombDropTimer <= 0) { this.dropBomb(); this.bombDropTimer = BOMB_DROP_INTERVAL_BASE + Math.random() * BOMB_DROP_INTERVAL_RANDOM; } } dropBomb() { spawnBomb(this.x, this.y + this.height / 2); } draw(ctx) { if (!this.active) return; const w = this.width; const h = this.height; const bodyW = w * 0.6; const wingH = h * 1.5; ctx.fillStyle = this.wingColor; ctx.beginPath(); ctx.moveTo(this.x - bodyW * 0.3, this.y); ctx.lineTo(this.x - w / 2, this.y - wingH / 2); ctx.lineTo(this.x - w / 2, this.y + wingH / 2); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(this.x + bodyW * 0.3, this.y); ctx.lineTo(this.x + w / 2, this.y - wingH / 2); ctx.lineTo(this.x + w / 2, this.y + wingH / 2); ctx.closePath(); ctx.fill(); ctx.fillStyle = this.color; ctx.fillRect(this.x - bodyW / 2, this.y - h / 2, bodyW, h); ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(this.x + (this.dx > 0 ? bodyW * 0.2 : -bodyW * 0.2), this.y, h * 0.3, 0, Math.PI * 2); ctx.fill(); } hit() { this.active = false; addScore(SCORE_BOMBER); spawnParticles(this.x, this.y, 20, this.color); maybeSpawnPowerUp(this.x, this.y); } }
        class Bomb extends GameObject { constructor(x, y) { super(x, y, GRID_SIZE * 0.4, GRID_SIZE * 0.6, 'grey'); this.speed = BOMB_SPEED; } update(deltaTime) { if (!this.active) return; this.y += this.speed; if (this.y > HEIGHT + this.height) { this.active = false; } } draw(ctx) { if (!this.active) return; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.width / 2, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#A9A9A9'; ctx.fillRect(this.x - this.width * 0.2, this.y - this.height * 0.6, this.width * 0.4, this.height * 0.3); } reset(x, y) { this.x = x; this.y = y; this.active = true; } }
        class PowerUp extends GameObject { constructor(x, y, type) { let color = 'white', symbol = '?'; switch(type) { case 'spread': color = 'cyan'; symbol = 'S'; break; case 'rapid': color = 'yellow'; symbol = 'R'; break; case 'shield': color = '#ADD8E6'; symbol = 'H'; break; case 'bomb': color = '#FF4500'; symbol = 'B'; break; } super(x, y, GRID_SIZE*0.7, GRID_SIZE*0.7, color); this.type=type; this.symbol = symbol; this.speed=1; } update(deltaTime) { if (!this.active) return; this.y+=this.speed; if (this.y>HEIGHT+this.height) this.active=false; if (player.active && this.collidesWith(player)) { this.apply(); this.active=false; } } draw(ctx) { if (!this.active) return; ctx.fillStyle=this.color; ctx.font="bold 12px Courier New"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.beginPath(); ctx.arc(this.x, this.y, this.width/2+2, 0, Math.PI*2); ctx.fill(); ctx.fillStyle="black"; ctx.fillText(this.symbol, this.x, this.y+1); } apply() { console.log(`Activated ${this.type} power-up!`); if (this.type !== 'shield') { activePowerUp = null; powerUpTimer = 0; } switch(this.type) { case 'spread': activePowerUp = this.type; powerUpTimer = BASE_POWERUP_DURATION; break; case 'rapid': activePowerUp = this.type; powerUpTimer = RAPID_FIRE_DURATION; break; case 'shield': player.isShielded = true; player.shieldTimer = SHIELD_DURATION; invincibilityTimer = 0; break; case 'bomb': triggerScreenClear(); break; } } }
        class Particle extends GameObject { constructor(x, y, color) { super(x, y, 3, 3, color); this.life=10+Math.random()*20; const a=Math.random()*Math.PI*2, s=1+Math.random()*3; this.vx=Math.cos(a)*s; this.vy=Math.sin(a)*s; this.alpha=1.0; } update(deltaTime) { if (!this.active) return; this.life--; if (this.life<=0) { this.active=false; return; } this.x+=this.vx; this.y+=this.vy; this.alpha=this.life/30; } draw(ctx) { if (!this.active || this.alpha<=0) return; ctx.globalAlpha=this.alpha; ctx.fillStyle=this.color; ctx.fillRect(this.x-this.width/2, this.y-this.height/2, this.width, this.height); ctx.globalAlpha=1.0; } reset(x, y, color) { this.x=x; this.y=y; this.color=color; this.life=10+Math.random()*20; const a=Math.random()*Math.PI*2, s=1+Math.random()*3; this.vx=Math.cos(a)*s; this.vy=Math.sin(a)*s; this.alpha=1.0; this.active=true; } }


        // --- Object Pooling & Game Logic Functions (Same structure, includes bomb pool/spawn) ---
        function initPools() { bulletPool.length = 0; particlePool.length = 0; bombPool.length = 0; for (let i=0; i<MAX_BULLETS; i++) { const b=new Bullet(0,0); b.active=false; bulletPool.push(b); } for (let i=0; i<MAX_PARTICLES; i++) { const p=new Particle(0,0,'white'); p.active=false; particlePool.push(p); } for (let i=0; i<MAX_BOMBS; i++) { const b=new Bomb(0,0); b.active=false; bombPool.push(b); } }
        function spawnBullet(x, y, angle = 0) { for (let i=0; i<bulletPool.length; i++) { if (!bulletPool[i].active) { bulletPool[i].reset(x, y, angle); return; } } }
        function spawnParticles(x, y, count, color) { let sc=0; for (let i=0; i<particlePool.length && sc<count; i++) { if (!particlePool[i].active) { particlePool[i].reset(x, y, color); sc++; } } }
        function spawnBomb(x, y) { for (let i = 0; i < bombPool.length; i++) { if (!bombPool[i].active) { bombPool[i].reset(x, y); return; } } }
        function initGame() { score=0; lives=3; level=1; isGameOver=false; gamePaused=false; nextLifeScore=EXTRA_LIFE_SCORE; activePowerUp=null; powerUpTimer=0; invincibilityTimer=0; isShielded=false; shieldTimer=0; isCentipedeAscending=false; keys={}; mouseX=WIDTH/2; mouseY=PLAYER_START_Y+GRID_SIZE; player=new Player(mouseX, mouseY); initPools(); initLevel(); updateUI(); lastTime=performance.now(); pausedTime=0; gameLoop(); }
        function initLevel() { bulletPool.forEach(b=>b.active=false); particlePool.forEach(p=>p.active=false); bombPool.forEach(b=>b.active=false); centipedeSegments=[]; spiders=[]; fleas=[]; scorpions=[]; bombers=[]; bombs=[]; powerUps=[]; player.x=WIDTH/2; player.y=PLAYER_START_Y+GRID_SIZE; mouseX=player.x; mouseY=player.y; invincibilityTimer=INVINCIBILITY_DURATION/2; isShielded = false; shieldTimer = 0; isCentipedeAscending = false; if (level === 1) { mushrooms = []; spawnMushrooms(30); } else { mushrooms.forEach(m => { if (m.active) { if(m.health<m.maxHealth){if (Math.random()<0.3) m.health=m.maxHealth; else m.health=Math.min(m.maxHealth, m.health+1);} m.updateVisuals(); } }); } spawnCentipede(); spiderSpawnTimer = calculateSpawnTime(5000, 4000, 150, MIN_SPIDER_SPAWN_TIME); fleaSpawnTimer = calculateSpawnTime(8000, 5000, 200, MIN_FLEA_SPAWN_TIME); scorpionSpawnTimer = calculateSpawnTime(12000, 7000, 250, MIN_SCORPION_SPAWN_TIME); bomberSpawnTimer = calculateSpawnTime(15000, 8000, 300, MIN_BOMBER_SPAWN_TIME); levelEl.textContent = `Level: ${level}`; }
        function calculateSpawnTime(base, rand, reduc, min) { const t = base - (level - 1) * reduc; return Math.max(min, t) + Math.random() * rand; }
        function spawnMushrooms(count) { let p = 0; while (p < count) { const gx=Math.floor(Math.random()*COLS), gy=Math.floor(Math.random()*(PLAYER_START_ROW-1))+1; const ex=mushrooms.some(m=>m.active && m.getGridPos().col===gx && m.getGridPos().row===gy); if (!ex) { mushrooms.push(new Mushroom(gx*GRID_SIZE, gy*GRID_SIZE)); p++; } } }
        function spawnMushroomAt(px, py) { const gx=Math.floor(px/GRID_SIZE), gy=Math.floor(py/GRID_SIZE); if (gy<=0 || gy>=ROWS-1) return; const ex=mushrooms.some(m=>m.active && m.getGridPos().col===gx && m.getGridPos().row===gy); if (!ex) mushrooms.push(new Mushroom(px, py)); else mushrooms.forEach(m => { if (m.active && m.getGridPos().col===gx && m.getGridPos().row===gy) { m.health=Math.min(m.maxHealth, m.health+1); m.updateVisuals(); addScore(SCORE_MUSHROOM_REPAIR); } }); }
        function spawnCentipede() { centipedeSegments = []; const len=CENTIPEDE_START_LENGTH+(level-1), sx=Math.floor(COLS/2)*GRID_SIZE+GRID_SIZE/2, sy=GRID_SIZE/2; let head=new CentipedeSegment(sx, sy, true); centipedeSegments.push(head); for (let i=1; i<len; i++) { const seg=new CentipedeSegment(sx-i*5, sy, false); centipedeSegments.push(seg); } for (let i=0; i<centipedeSegments.length-1; i++) centipedeSegments[i].nextSegment=centipedeSegments[i+1]; }
        let spiderSpawnTimer = 5000; function spawnSpiderLogic(dt){ spiderSpawnTimer-=dt; if (spiderSpawnTimer<=0 && spiders.length===0) { const sx=Math.random()<0.5?GRID_SIZE:WIDTH-GRID_SIZE, sy=PLAYER_START_Y+Math.random()*(HEIGHT-PLAYER_START_Y-GRID_SIZE); spiders.push(new Spider(sx, sy)); spiderSpawnTimer=calculateSpawnTime(5000, 4000, 150, MIN_SPIDER_SPAWN_TIME); } }
        let fleaSpawnTimer = 8000; function spawnFleaLogic(dt) { fleaSpawnTimer-=dt; if (fleaSpawnTimer<=0 && fleas.length===0) { let pm=0; mushrooms.forEach(m=>{if (m.active && m.getGridPos().row>=PLAYER_START_ROW) pm++;}); if (pm<=FLEA_SPAWN_THRESHOLD) fleas.push(new Flea()); fleaSpawnTimer=calculateSpawnTime(8000, 5000, 200, MIN_FLEA_SPAWN_TIME); } }
        let scorpionSpawnTimer = 10000; function spawnScorpionLogic(dt) { scorpionSpawnTimer-=dt; if (scorpionSpawnTimer<=0 && scorpions.length===0) { scorpions.push(new Scorpion()); scorpionSpawnTimer=calculateSpawnTime(12000, 7000, 250, MIN_SCORPION_SPAWN_TIME); } }
        let bomberSpawnTimer = 15000; function spawnBomberLogic(dt) { bomberSpawnTimer -= dt; if (bomberSpawnTimer <= 0 && bombers.length === 0) { bombers.push(new Bomber()); bomberSpawnTimer = calculateSpawnTime(15000, 8000, 300, MIN_BOMBER_SPAWN_TIME); } }
        function maybeSpawnPowerUp(x, y) { if (Math.random() < POWERUP_DROP_CHANCE) { const rand = Math.random(); let type; if (rand < 0.3) type = 'spread'; else if (rand < 0.6) type = 'rapid'; else if (rand < 0.85) type = 'shield'; else type = 'bomb'; powerUps.push(new PowerUp(x, y, type)); } }
        function triggerPoisonExplosion(x, y) { console.log("Poison Boom!"); spawnParticles(x, y, 40, 'lime'); const radiusSq = POISON_EXPLOSION_RADIUS * POISON_EXPLOSION_RADIUS; mushrooms.forEach(m => { if (m.active) { const dx = m.x - x, dy = m.y - y; if (dx * dx + dy * dy < radiusSq) { if(m.x !== x || m.y !== y) { m.hit(); spawnParticles(m.x, m.y, 5, 'lime'); } } } }); const enemies = [...centipedeSegments, ...spiders, ...fleas, ...scorpions, ...bombers]; enemies.forEach(e => { if (e.active) { const dx = e.x - x, dy = e.y - y; if (dx * dx + dy * dy < radiusSq) e.hit(); } }); }
        function triggerScreenClear() { console.log("Screen Clear!"); spawnParticles(WIDTH/2, HEIGHT/2, 100, 'white'); const enemies = [...centipedeSegments, ...spiders, ...fleas, ...scorpions, ...bombers]; enemies.forEach(e => { if (e.active) e.hit(); }); bombPool.forEach(b => { if(b.active) { b.active = false; spawnParticles(b.x, b.y, 5, b.color); } }); bombs = []; }
        function update(currentTime) { if (gamePaused) { pausedTime = currentTime - lastTime; return; } if (pausedTime > 0) { lastTime = currentTime - (pausedTime > 100 ? 16 : pausedTime); pausedTime = 0; } const deltaTime = Math.min(50, currentTime - lastTime); lastTime = currentTime; if (isGameOver && lives <= 0) return; if (isGameOver && lives > 0) return; player.update(deltaTime); bulletPool.forEach(b=>{if(b.active)b.update(deltaTime);}); bombPool.forEach(b=>{if(b.active)b.update(deltaTime);}); centipedeSegments.forEach(s=>s.update(deltaTime)); spiders.forEach(s=>s.update(deltaTime)); fleas.forEach(f=>f.update(deltaTime)); scorpions.forEach(s=>s.update(deltaTime)); bombers.forEach(b=>b.update(deltaTime)); powerUps.forEach(p=>p.update(deltaTime)); particlePool.forEach(p=>{if(p.active)p.update(deltaTime);}); spiders=spiders.filter(s=>s.active); fleas=fleas.filter(f=>f.active); scorpions=scorpions.filter(s=>s.active); bombers=bombers.filter(b=>b.active); bombs=bombPool.filter(b=>b.active); powerUps=powerUps.filter(p=>p.active); spawnSpiderLogic(deltaTime); spawnFleaLogic(deltaTime); spawnScorpionLogic(deltaTime); spawnBomberLogic(deltaTime); checkCollisions(); if (!isCentipedeAscending) { for (const segment of centipedeSegments) { if (segment.active && segment.y >= PLAYER_START_Y - GRID_SIZE / 2) { isCentipedeAscending = true; console.log("Centipede Ascending!"); centipedeSegments.forEach(seg => { if (seg.active) { seg.dy = -1; seg.targetY = seg.getCenterGridPos().row - 1; seg.updateSpeedForLevel(true); } }); break; } } } if (centipedeSegments.every(seg => !seg.active) && !isGameOver && !gamePaused) { isGameOver = true; level++; spawnParticles(WIDTH/2, HEIGHT/2, 50, 'gold'); setTimeout(() => { isGameOver = false; initLevel(); }, 1500); } }
        function checkCollisions() { bulletPool.forEach(bullet => { if (!bullet.active) return; mushrooms.forEach(m => { if(m.active && bullet.collidesWith(m)){bullet.active=false; m.hit();}}); if (!bullet.active) return; centipedeSegments.forEach(s => { if(s.active && bullet.collidesWith(s)){bullet.active=false; s.hit();}}); if (!bullet.active) return; spiders.forEach(s => { if(s.active && bullet.collidesWith(s)){bullet.active=false; s.hit();}}); if (!bullet.active) return; fleas.forEach(f => { if(f.active && bullet.collidesWith(f)){bullet.active=false; f.hit();}}); if (!bullet.active) return; scorpions.forEach(s => { if(s.active && bullet.collidesWith(s)){bullet.active=false; s.hit();}}); if (!bullet.active) return; bombers.forEach(b => { if(b.active && bullet.collidesWith(b)){bullet.active=false; b.hit();}}); }); if (player.active && !player.isShielded && invincibilityTimer <= 0) { const threats = [...centipedeSegments, ...spiders, ...fleas, ...scorpions, ...bombers, ...bombs]; for (const threat of threats) { if (threat.active && player.collidesWith(threat)) { player.hit(); if (threat instanceof Bomb) { threat.active = false; spawnParticles(threat.x, threat.y, 8, threat.color); } return; } } } else if (player.active && player.isShielded) { const threats = [...centipedeSegments, ...spiders, ...fleas, ...scorpions, ...bombers, ...bombs]; for (const threat of threats) { if (threat.active && player.collidesWith(threat)) { spawnParticles(player.x, player.y, 5, 'cyan'); if (threat instanceof Bomb) { threat.active = false; spawnParticles(threat.x, threat.y, 8, threat.color); } } } } bombPool.forEach(bomb => { if (!bomb.active) return; mushrooms.forEach(m => { if (m.active && bomb.collidesWith(m)) { bomb.active = false; m.hit(); spawnParticles(bomb.x, bomb.y, 8, bomb.color); } }); }); }
        function draw() { ctx.fillStyle='black'; ctx.fillRect(0, 0, WIDTH, HEIGHT); mushrooms.forEach(m=>m.draw(ctx)); bombs.forEach(b=>b.draw(ctx)); bulletPool.forEach(b=>{if(b.active)b.draw(ctx);}); powerUps.forEach(p=>p.draw(ctx)); centipedeSegments.filter(s=>s.active&&!s.isHead).forEach(s=>s.draw(ctx)); centipedeSegments.filter(s=>s.active&&s.isHead).forEach(s=>s.draw(ctx)); spiders.forEach(s=>s.draw(ctx)); fleas.forEach(f=>f.draw(ctx)); scorpions.forEach(s=>s.draw(ctx)); bombers.forEach(b=>b.draw(ctx)); player.draw(ctx); particlePool.forEach(p=>{if(p.active)p.draw(ctx);}); if (gamePaused) { ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(0, 0, WIDTH, HEIGHT); ctx.fillStyle = 'yellow'; ctx.font = 'bold 40px Courier New'; ctx.textAlign = 'center'; ctx.fillText('PAUSED', WIDTH / 2, HEIGHT / 2); } }
        function updateUI() { scoreEl.textContent=`Score: ${score}`; livesEl.textContent=`Lives: ${lives}`; }
        function addScore(points) { score+=points; if (score>=nextLifeScore) { lives++; nextLifeScore+=EXTRA_LIFE_SCORE; console.log("Extra Life!"); } updateUI(); }
        function drawGameOver() { ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(0,0,WIDTH,HEIGHT); ctx.fillStyle='red'; ctx.font='48px Courier New'; ctx.textAlign='center'; ctx.fillText('GAME OVER', WIDTH/2, HEIGHT/2-50); ctx.fillStyle='white'; ctx.font='24px Courier New'; ctx.fillText(`Final Score: ${score}`, WIDTH/2, HEIGHT/2); ctx.font='18px Courier New'; ctx.fillText(isTouchDevice?'Tap Screen to Restart':'Press Enter to Restart', WIDTH/2, HEIGHT/2+50); }
        function gameLoop(currentTime = 0) { if (isGameOver && lives <= 0) { drawGameOver(); requestAnimationFrame(gameLoop); return; } update(currentTime); draw(); requestAnimationFrame(gameLoop); }

        // --- Input Handling ---
        // Add explanatory comments for scanner
        // Handles keyboard input for player movement, shooting (non-touch), pause, and restart.
        window.addEventListener('keydown', (e) => { keys[e.key]=true; if (e.key==='p'||e.key==='P'){ if (!isGameOver) { gamePaused=!gamePaused; if (!gamePaused) lastTime=performance.now()-16; else lastTime=performance.now(); console.log("Game Paused:", gamePaused); } } if (isGameOver && lives<=0 && e.key==='Enter' && !isTouchDevice) initGame(); if ([' ','ArrowUp','ArrowDown','ArrowLeft','ArrowRight','p','P'].includes(e.key)) e.preventDefault(); });
        window.addEventListener('keyup', (e) => { keys[e.key]=false; });
        // Handles mouse movement for player control (non-touch)
        canvas.addEventListener('mousemove', (e) => { if (isTouchDevice||gamePaused) return; const rect=canvas.getBoundingClientRect(); mouseX=e.clientX-rect.left; mouseY=e.clientY-rect.top; });
        // Handles mouse click for shooting (non-touch)
        canvas.addEventListener('mousedown', (e) => { if (isTouchDevice||gamePaused) return; if (!isGameOver && player) { player.triggerShoot(); e.preventDefault(); } });
        canvas.addEventListener('mouseleave', ()=>{}); canvas.addEventListener('mouseenter', ()=>{if (!isTouchDevice) canvas.style.cursor='none';});
        // Handles touch input for player movement and restart (touch devices)
        function handleTouch(e) { if (gamePaused) return; if (!e.touches||e.touches.length===0) return; e.preventDefault(); const rect=canvas.getBoundingClientRect(), touch=e.touches[0]; mouseX=touch.clientX-rect.left; mouseY=touch.clientY-rect.top; if (isGameOver && lives<=0 && e.type==='touchstart') initGame(); }
        canvas.addEventListener('touchstart', handleTouch, {passive: false});
        canvas.addEventListener('touchmove', handleTouch, {passive: false});

        // --- Start Game ---
        initGame();

    // --- End of IIFE ---
    })();
    </script>
</body>
</html>